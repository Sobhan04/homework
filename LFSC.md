R.Homework
================
Sobhan Bahrami
5/3/2022

## Homework for Module 1.1: R

For my homework, I used the results of one of my recent projects. In
this project, I tried to analyze RNA-SEQ data for a specific species.
Our aim was to compare the expression level of different genes between
different treatments. So, the file that I used for this homework was
generated by the HT-Seq tool. In this file, we have information about
the numbers of reads for each gene for four samples (two treatments and
two replications per treatment). There are around 15500 genes for this
specific species and we expect to see consistent data between
replications for each treatment. My aim is to calculate the slope of the
linear model for each treatment to see if they are consistent or not.
The data that I am using is not normalized and I have to first normalize
it according to the total read count for each sample. Also, the lengths
of genes are important because we will have more reads for larger genes.
In the input file, we have a column that shows if the gene is large (L)
(&gt;3500bp) or small (S)(&lt;=3500bp).

The first step is to import the read count file in R. For this step, I
used the following command:

``` r
read_counts <- read_csv("/home/sobhan/Desktop/Bowtie_aligned_>=1_time_without_normalization.txt")
```

    ## New names:
    ## * `` -> ...1

    ## Rows: 15544 Columns: 6

    ## ── Column specification ────────────────────────────────────────────────────────
    ## Delimiter: ","
    ## chr (2): ...1, Length
    ## dbl (4): Two_Four_c_rep1, Two_Four_c_rep2, Four_Eight_c_rep1, Four_Eight_c_rep2

    ## 
    ## ℹ Use `spec()` to retrieve the full column specification for this data.
    ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.

``` r
print(read_counts)
```

    ## # A tibble: 15,544 × 6
    ##    ...1   Length Two_Four_c_rep1 Two_Four_c_rep2 Four_Eight_c_rep1
    ##    <chr>  <chr>            <dbl>           <dbl>             <dbl>
    ##  1 g00001 L                    0               0                 0
    ##  2 g00002 L                    0               0                 0
    ##  3 g00003 L                    0               0                 0
    ##  4 g00004 S                    1               0                 0
    ##  5 g00005 L                    0               0                 0
    ##  6 g00006 S                    0               0                 0
    ##  7 g00007 L                    0               0                 0
    ##  8 g00008 L                  880              94               626
    ##  9 g00009 S                 1414             116              1099
    ## 10 g00010 S                 2028             176              1718
    ## # … with 15,534 more rows, and 1 more variable: Four_Eight_c_rep2 <dbl>

Now, I want to calculate the average of read counts in each sample.
Therefore, I used the following command for this purpose:

``` r
Average<-c(Two_Four_c_rep1=mean(read_counts$Two_Four_c_rep1),Two_Four_c_rep2=mean(read_counts$Two_Four_c_rep2),Four_Eight_c_rep1=mean(read_counts$Four_Eight_c_rep1),Four_Eight_c_rep2=mean(read_counts$Four_Eight_c_rep2))
Average
```

    ##   Two_Four_c_rep1   Two_Four_c_rep2 Four_Eight_c_rep1 Four_Eight_c_rep2 
    ##         468.15569          66.84077         458.41476          80.50335

According to this result, we first need to normalize our data. However,
I also want to calculate the average of read counts for large and small
genes in each sample. To do so, I used the following command:

``` r
read_counts_summ <- read_counts %>%
  group_by(Length) %>%
  summarise(mean.Two_Four_c_rep1 = mean(Two_Four_c_rep1, na.rm = TRUE),
            mean.Two_Four_c_rep2 = mean(Two_Four_c_rep2, na.rm = TRUE),
            mean.Four_Eight_c_rep1 = mean(Four_Eight_c_rep1, na.rm = TRUE),
            mean.Four_Eight_c_rep2 = mean(Four_Eight_c_rep2, na.rm = TRUE))
read_counts_summ 
```

    ## # A tibble: 2 × 5
    ##   Length mean.Two_Four_c_rep1 mean.Two_Four_c… mean.Four_Eight… mean.Four_Eight…
    ##   <chr>                 <dbl>            <dbl>            <dbl>            <dbl>
    ## 1 L                      491.             77.1             491.             99.8
    ## 2 S                      438.             53.4             415.             55.1

According to these results, as we expected, the average of the read
counts for larger genes is more than the mean read counts for small
genes in each sample. Now, I want to normalize the data according to the
total read count for each sample. So here I calculated the total read
count for each sample and then calculated the normalized read counts for
each sample. So, after this step, the total read count for each sample
will be 1.000.000.

``` r
read_counts_norm <- read_counts %>%
  group_by(Length) %>%
  mutate(norm.Two_Four_c_rep1 = Two_Four_c_rep1 * (1000000/sum(Two_Four_c_rep1, na.rm = TRUE)),
         norm.Two_Four_c_rep2 = Two_Four_c_rep2 * (1000000/sum(Two_Four_c_rep2, na.rm = TRUE)),
         norm.Four_Eight_c_rep1 = Four_Eight_c_rep1 * (1000000/sum(Four_Eight_c_rep1, na.rm = TRUE)),
         norm.Four_Eight_c_rep2 = Four_Eight_c_rep2 * (1000000/sum(Four_Eight_c_rep2, na.rm = TRUE)))
glimpse(read_counts_norm)
```

    ## Rows: 15,544
    ## Columns: 10
    ## Groups: Length [2]
    ## $ ...1                   <chr> "g00001", "g00002", "g00003", "g00004", "g00005…
    ## $ Length                 <chr> "L", "L", "L", "S", "L", "S", "L", "L", "S", "S…
    ## $ Two_Four_c_rep1        <dbl> 0, 0, 0, 1, 0, 0, 0, 880, 1414, 2028, 6007, 271…
    ## $ Two_Four_c_rep2        <dbl> 0, 0, 0, 0, 0, 0, 0, 94, 116, 176, 438, 12, 19,…
    ## $ Four_Eight_c_rep1      <dbl> 0, 0, 0, 0, 0, 0, 0, 626, 1099, 1718, 4686, 451…
    ## $ Four_Eight_c_rep2      <dbl> 0, 0, 0, 0, 0, 0, 0, 130, 123, 183, 661, 28, 9,…
    ## $ norm.Two_Four_c_rep1   <dbl> 0.0000000, 0.0000000, 0.0000000, 0.3404518, 0.0…
    ## $ norm.Two_Four_c_rep2   <dbl> 0.000000, 0.000000, 0.000000, 0.000000, 0.00000…
    ## $ norm.Four_Eight_c_rep1 <dbl> 0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0…
    ## $ norm.Four_Eight_c_rep2 <dbl> 0.000000, 0.000000, 0.000000, 0.000000, 0.00000…

``` r
read_counts_norm
```

    ## # A tibble: 15,544 × 10
    ## # Groups:   Length [2]
    ##    ...1   Length Two_Four_c_rep1 Two_Four_c_rep2 Four_Eight_c_rep1
    ##    <chr>  <chr>            <dbl>           <dbl>             <dbl>
    ##  1 g00001 L                    0               0                 0
    ##  2 g00002 L                    0               0                 0
    ##  3 g00003 L                    0               0                 0
    ##  4 g00004 S                    1               0                 0
    ##  5 g00005 L                    0               0                 0
    ##  6 g00006 S                    0               0                 0
    ##  7 g00007 L                    0               0                 0
    ##  8 g00008 L                  880              94               626
    ##  9 g00009 S                 1414             116              1099
    ## 10 g00010 S                 2028             176              1718
    ## # … with 15,534 more rows, and 5 more variables: Four_Eight_c_rep2 <dbl>,
    ## #   norm.Two_Four_c_rep1 <dbl>, norm.Two_Four_c_rep2 <dbl>,
    ## #   norm.Four_Eight_c_rep1 <dbl>, norm.Four_Eight_c_rep2 <dbl>

The next step is to create a list column of our data frame. So, I did
this step by using `nest()` and then I defined a function to calculate a
linear regression for each treatment. In this step `lm()` function was
used. Also, to get the slope of the linear model for each treatment I
wrote a new function, `get_slope`.

These steps should be repeated for both of our treatments. First, I did
it for the “Four\_Eight\_c” treatment:

``` r
nested_df <- read_counts_norm %>%
  group_by(Length) %>%
  nest()
#nested_df$data[[1]]
glimpse(nested_df$data[[1]])
```

    ## Rows: 8,843
    ## Columns: 9
    ## $ ...1                   <chr> "g00001", "g00002", "g00003", "g00005", "g00007…
    ## $ Two_Four_c_rep1        <dbl> 0, 0, 0, 0, 0, 880, 6007, 271, 298, 2011, 1, 35…
    ## $ Two_Four_c_rep2        <dbl> 0, 0, 0, 0, 0, 94, 438, 12, 19, 176, 0, 8, 0, 0…
    ## $ Four_Eight_c_rep1      <dbl> 0, 0, 0, 0, 0, 626, 4686, 451, 159, 1321, 0, 76…
    ## $ Four_Eight_c_rep2      <dbl> 0, 0, 0, 0, 0, 130, 661, 28, 9, 246, 0, 30, 3, …
    ## $ norm.Two_Four_c_rep1   <dbl> 0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0…
    ## $ norm.Two_Four_c_rep2   <dbl> 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 13…
    ## $ norm.Four_Eight_c_rep1 <dbl> 0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0…
    ## $ norm.Four_Eight_c_rep2 <dbl> 0.000000, 0.000000, 0.000000, 0.000000, 0.00000…

``` r
glimpse(nested_df)
```

    ## Rows: 2
    ## Columns: 2
    ## Groups: Length [2]
    ## $ Length <chr> "L", "S"
    ## $ data   <list> [<tbl_df[8843 x 9]>], [<tbl_df[6701 x 9]>]

``` r
lm_fun <- function(df) {
  lm(norm.Four_Eight_c_rep1 ~ norm.Four_Eight_c_rep2, data = df)
}
nested_df_2.2 <- nested_df %>%
  mutate(lms = map(data, lm_fun))
summary(nested_df_2.2$lms[[1]])
```

    ## 
    ## Call:
    ## lm(formula = norm.Four_Eight_c_rep1 ~ norm.Four_Eight_c_rep2, 
    ##     data = df)
    ## 
    ## Residuals:
    ##      Min       1Q   Median       3Q      Max 
    ## -3016.96   -11.80   -10.57    -0.63  2459.07 
    ## 
    ## Coefficients:
    ##                         Estimate Std. Error t value Pr(>|t|)    
    ## (Intercept)            11.031147   1.454669   7.583 3.71e-14 ***
    ## norm.Four_Eight_c_rep2  0.902452   0.004409 204.673  < 2e-16 ***
    ## ---
    ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
    ## 
    ## Residual standard error: 128.5 on 8841 degrees of freedom
    ## Multiple R-squared:  0.8257, Adjusted R-squared:  0.8257 
    ## F-statistic: 4.189e+04 on 1 and 8841 DF,  p-value: < 2.2e-16

``` r
get_slope <- function(my.lm) {
  coef(my.lm)[2]
}

slopes <- nested_df_2.2 %>%
  mutate(slope = map_dbl(lms, get_slope))
print(slopes)
```

    ## # A tibble: 2 × 4
    ## # Groups:   Length [2]
    ##   Length data                 lms    slope
    ##   <chr>  <list>               <list> <dbl>
    ## 1 L      <tibble [8,843 × 9]> <lm>   0.902
    ## 2 S      <tibble [6,701 × 9]> <lm>   0.982

According to these results, we can see that the slopes of the linear
models in the Four\_Eight\_c treatment for both large and small genes
are close to each other and for small genes is near to 1, which is
perfect.

And again I repeated the previous steps for the “Two\_Four\_c”
treatment:

``` r
nested_df <- read_counts_norm %>%
  group_by(Length) %>%
  nest()
#nested_df$data[[1]]
glimpse(nested_df$data[[1]])
```

    ## Rows: 8,843
    ## Columns: 9
    ## $ ...1                   <chr> "g00001", "g00002", "g00003", "g00005", "g00007…
    ## $ Two_Four_c_rep1        <dbl> 0, 0, 0, 0, 0, 880, 6007, 271, 298, 2011, 1, 35…
    ## $ Two_Four_c_rep2        <dbl> 0, 0, 0, 0, 0, 94, 438, 12, 19, 176, 0, 8, 0, 0…
    ## $ Four_Eight_c_rep1      <dbl> 0, 0, 0, 0, 0, 626, 4686, 451, 159, 1321, 0, 76…
    ## $ Four_Eight_c_rep2      <dbl> 0, 0, 0, 0, 0, 130, 661, 28, 9, 246, 0, 30, 3, …
    ## $ norm.Two_Four_c_rep1   <dbl> 0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0…
    ## $ norm.Two_Four_c_rep2   <dbl> 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 13…
    ## $ norm.Four_Eight_c_rep1 <dbl> 0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0…
    ## $ norm.Four_Eight_c_rep2 <dbl> 0.000000, 0.000000, 0.000000, 0.000000, 0.00000…

``` r
glimpse(nested_df)
```

    ## Rows: 2
    ## Columns: 2
    ## Groups: Length [2]
    ## $ Length <chr> "L", "S"
    ## $ data   <list> [<tbl_df[8843 x 9]>], [<tbl_df[6701 x 9]>]

``` r
lm_fun <- function(df) {
  lm(norm.Two_Four_c_rep1 ~ norm.Two_Four_c_rep2, data = df)
}
nested_df_2.1 <- nested_df %>%
  mutate(lms = map(data, lm_fun))
summary(nested_df_2.1$lms[[1]])
```

    ## 
    ## Call:
    ## lm(formula = norm.Two_Four_c_rep1 ~ norm.Two_Four_c_rep2, data = df)
    ## 
    ## Residuals:
    ##     Min      1Q  Median      3Q     Max 
    ## -3994.3    -0.3     2.8     5.3  4284.6 
    ## 
    ## Coefficients:
    ##                       Estimate Std. Error t value Pr(>|t|)    
    ## (Intercept)          -2.754255   1.783324  -1.544    0.123    
    ## norm.Two_Four_c_rep2  1.024356   0.005334 192.026   <2e-16 ***
    ## ---
    ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
    ## 
    ## Residual standard error: 157.8 on 8841 degrees of freedom
    ## Multiple R-squared:  0.8066, Adjusted R-squared:  0.8066 
    ## F-statistic: 3.687e+04 on 1 and 8841 DF,  p-value: < 2.2e-16

``` r
get_slope <- function(my.lm) {
  coef(my.lm)[2]
}

slopes <- nested_df_2.1 %>%
  mutate(slope = map_dbl(lms, get_slope))
print(slopes)
```

    ## # A tibble: 2 × 4
    ## # Groups:   Length [2]
    ##   Length data                 lms    slope
    ##   <chr>  <list>               <list> <dbl>
    ## 1 L      <tibble [8,843 × 9]> <lm>    1.02
    ## 2 S      <tibble [6,701 × 9]> <lm>    1.03

And also we can see that for this treatment the slopes of the linear
models are close to 1 which is good.

## Plots

Now I want to use ggplot2 to show my data and compare the replications
together more easily

For “Two\_Four\_c” treatment:

``` r
#png(file="/home/sobhan/Desktop/2_4_c_rep1.VS.2_4_c_rep2.png", width=1200, height=900)
ggplot(nested_df$data[[2]], aes(x=norm.Two_Four_c_rep1, y=norm.Two_Four_c_rep2)) +
  geom_point(shape=18, color="orange")+
  #geom_text(label=read_counts$Gene)+
  geom_smooth(method=lm, se=FALSE, linetype="dashed", color="blue")+ geom_rug()+labs(x = expression(italic(Two_Four_c_rep1)), y = expression(italic(Two_Four_c_rep2)))
```

    ## `geom_smooth()` using formula 'y ~ x'

![](LFSC_files/figure-gfm/Plot%201-1.png)<!-- -->

And for the “Four\_Eight\_c” treatment:

``` r
#png(file="/home/sobhan/Desktop/4_8_c_rep1.VS.4_8_c_rep2.png", width=1200, height=900)
ggplot(nested_df$data[[1]], aes(x=norm.Four_Eight_c_rep1, y=norm.Four_Eight_c_rep2)) +
  geom_point(shape=18, color="orange")+
  #geom_text(label=read_counts$Gene)
  geom_smooth(method=lm, se=FALSE, linetype="dashed", color="blue")+ geom_rug()+
  labs(x = expression(italic(Four_Eight_c_rep1)), y = expression(italic(Four_Eight_c_rep2)))
```

    ## `geom_smooth()` using formula 'y ~ x'

![](LFSC_files/figure-gfm/Plot%202-1.png)<!-- -->

So these results indicate that the normalization step was done correctly
and our replications for each treatment are consistent. For our study,
in which we want to compare the read counts for genes between different
treatments, this kind of normalization is suitable. However, we can also
consider the lengths of the genes and try to normalize the data
according to their lengths. This step may help us to make our data more
consistent.
